/*
 * MonitorGUI.java
 *
 * Created on April 30, 2007, 3:36 PM
 */

package org.globus.GenericPortal.clients.GPService_instance;

import java.io.*;

import javax.xml.rpc.Stub;
import org.globus.wsrf.impl.security.authorization.NoAuthorization;
import org.globus.wsrf.security.Constants;
import org.globus.wsrf.impl.security.authorization.SelfAuthorization;
import org.globus.wsrf.client.BaseClient;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.CommandLine;
import org.globus.wsrf.impl.security.authentication.*;
import org.globus.axis.gsi.GSIConstants;
import org.globus.axis.util.Util;
import org.globus.GenericPortal.common.*;

import java.io.FileInputStream;

import org.apache.axis.message.addressing.Address;
import org.apache.axis.message.addressing.EndpointReferenceType;
import org.globus.GenericPortal.services.core.WS.impl.GPConstants;
import org.globus.GenericPortal.stubs.GPService_instance.GPPortType;
import org.globus.GenericPortal.stubs.GPService_instance.service.GPServiceAddressingLocator;
import org.globus.wsrf.ResourceKey;

import org.globus.wsrf.encoding.ObjectDeserializer;
import org.oasis.wsrf.properties.GetResourcePropertyResponse;
import org.xml.sax.InputSource;
//import org.apache.axis.message.addressing.AttributedURI;


import org.globus.wsrf.utils.AddressingUtils;

import org.globus.GenericPortal.stubs.GPService_instance.*;

import java.net.*;
import java.util.*;
import java.io.*;
import java.lang.*;//ThreadLocal
import java.util.zip.*;

import org.globus.GenericPortal.common.*;

import org.globus.GenericPortal.clients.GPService_instance.*;

/**
 *
 * @author  iraicu
 */
public class MonitorGUI extends javax.swing.JFrame {
    public String serviceURI;
    public long pollTime;

    public boolean DEBUG = false;
    public boolean DIPERF = false;
    //public boolean MODE_GUI;
    //public boolean MODE_TEXT;
    //public boolean MODE_TEXT_UI;

    public String CLIENT_DESC;



    /** Creates new form MonitorGUI */
    public MonitorGUI()
    {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">
    private void initComponents() {
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        resourcePane = new javax.swing.JDesktopPane();
        jLabel7 = new javax.swing.JLabel();
        allocatedExecutors = new javax.swing.JTextField();
        registeredExecutors = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        freeExecutors = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        pendingExecutors = new javax.swing.JTextField();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        activeExecutors = new javax.swing.JTextField();
        jLabel12 = new javax.swing.JLabel();
        generalPane = new javax.swing.JDesktopPane();
        exitButton = new javax.swing.JButton();
        connectButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        machName = new javax.swing.JTextField();
        machPort = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        securityCheckBox = new javax.swing.JCheckBox();
        statusText = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        pollingInterval = new javax.swing.JTextField();
        jLabel11 = new javax.swing.JLabel();
        falkonConfigPane = new javax.swing.JDesktopPane();
        bundling = new javax.swing.JTextField();
        jLabel13 = new javax.swing.JLabel();
        piggyBacking = new javax.swing.JTextField();
        jLabel14 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        preFetching = new javax.swing.JTextField();
        jLabel16 = new javax.swing.JLabel();
        dataCaching = new javax.swing.JTextField();
        scheduler = new javax.swing.JTextField();
        jLabel21 = new javax.swing.JLabel();
        jLabel22 = new javax.swing.JLabel();
        tasksPane = new javax.swing.JDesktopPane();
        numQueues = new javax.swing.JTextField();
        jLabel23 = new javax.swing.JLabel();
        jLabel24 = new javax.swing.JLabel();
        waitQlength = new javax.swing.JTextField();
        activeTasks = new javax.swing.JTextField();
        deliverQtasks = new javax.swing.JTextField();
        deliveredTasks = new javax.swing.JTextField();
        jLabel25 = new javax.swing.JLabel();
        jLabel26 = new javax.swing.JLabel();
        jLabel27 = new javax.swing.JLabel();
        jLabel28 = new javax.swing.JLabel();
        perfPane = new javax.swing.JDesktopPane();
        submitTP = new javax.swing.JTextField();
        jLabel29 = new javax.swing.JLabel();
        jLabel31 = new javax.swing.JLabel();
        dispatchTP = new javax.swing.JTextField();
        jLabel32 = new javax.swing.JLabel();
        deliveredTP = new javax.swing.JTextField();
        jLabel33 = new javax.swing.JLabel();
        systemPane = new javax.swing.JDesktopPane();
        numThreads = new javax.swing.JTextField();
        jLabel30 = new javax.swing.JLabel();
        cpuUtilizationUser = new javax.swing.JTextField();
        heapFree = new javax.swing.JTextField();
        heapMax = new javax.swing.JTextField();
        jLabel34 = new javax.swing.JLabel();
        jLabel35 = new javax.swing.JLabel();
        jLabel36 = new javax.swing.JLabel();
        jLabel37 = new javax.swing.JLabel();
        heapSize = new javax.swing.JTextField();
        jLabel46 = new javax.swing.JLabel();
        cpuUtilizationSystem = new javax.swing.JTextField();
        cpuUtilizationIdle = new javax.swing.JTextField();
        jLabel47 = new javax.swing.JLabel();
        jLabel48 = new javax.swing.JLabel();
        cachingPane = new javax.swing.JDesktopPane();
        jLabel38 = new javax.swing.JLabel();
        indexSize = new javax.swing.JTextField();
        jLabel39 = new javax.swing.JLabel();
        cacheHits = new javax.swing.JTextField();
        cacheMisses = new javax.swing.JTextField();
        jLabel40 = new javax.swing.JLabel();
        jLabel41 = new javax.swing.JLabel();
        cacheHitRatio = new javax.swing.JTextField();
        jLabel42 = new javax.swing.JLabel();
        drpConfigPane = new javax.swing.JDesktopPane();
        jLabel43 = new javax.swing.JLabel();
        drpMinResc = new javax.swing.JTextField();
        jLabel17 = new javax.swing.JLabel();
        drpMaxResc = new javax.swing.JTextField();
        jLabel18 = new javax.swing.JLabel();
        drpMinTime = new javax.swing.JTextField();
        jLabel19 = new javax.swing.JLabel();
        drpMaxTime = new javax.swing.JTextField();
        jLabel20 = new javax.swing.JLabel();
        drpAllocation = new javax.swing.JTextField();
        drpIdle = new javax.swing.JTextField();
        jLabel44 = new javax.swing.JLabel();
        jLabel45 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 24));
        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel4.setText("Falkon Monitor v0.9");

        jLabel5.setFont(new java.awt.Font("Tahoma", 0, 12));
        jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel5.setText("http://people.cs.uchicago.edu/~iraicu/research/Falkon/");

        resourcePane.setBackground(new java.awt.Color(0, 153, 255));
        jLabel7.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel7.setText("Allocated");
        jLabel7.setBounds(20, 30, 100, 13);
        resourcePane.add(jLabel7, javax.swing.JLayeredPane.DEFAULT_LAYER);

        allocatedExecutors.setEditable(false);
        allocatedExecutors.setBounds(10, 50, 100, 20);
        resourcePane.add(allocatedExecutors, javax.swing.JLayeredPane.DEFAULT_LAYER);

        registeredExecutors.setEditable(false);
        registeredExecutors.setBounds(130, 50, 100, 20);
        resourcePane.add(registeredExecutors, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel6.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel6.setText("Registered");
        jLabel6.setBounds(130, 30, 110, 13);
        resourcePane.add(jLabel6, javax.swing.JLayeredPane.DEFAULT_LAYER);

        freeExecutors.setEditable(false);
        freeExecutors.setBounds(240, 50, 100, 20);
        resourcePane.add(freeExecutors, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel8.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel8.setText("Free");
        jLabel8.setBounds(240, 30, 34, 13);
        resourcePane.add(jLabel8, javax.swing.JLayeredPane.DEFAULT_LAYER);

        pendingExecutors.setEditable(false);
        pendingExecutors.setBounds(350, 50, 100, 20);
        resourcePane.add(pendingExecutors, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel9.setFont(new java.awt.Font("Tahoma", 1, 18));
        jLabel9.setText("Resources");
        jLabel9.setBounds(0, 0, 210, 22);
        resourcePane.add(jLabel9, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel10.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel10.setText("Pending");
        jLabel10.setBounds(350, 30, 37, 13);
        resourcePane.add(jLabel10, javax.swing.JLayeredPane.DEFAULT_LAYER);

        activeExecutors.setEditable(false);
        activeExecutors.setBounds(460, 50, 100, 20);
        resourcePane.add(activeExecutors, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel12.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel12.setText("Active");
        jLabel12.setBounds(460, 30, 28, 13);
        resourcePane.add(jLabel12, javax.swing.JLayeredPane.DEFAULT_LAYER);

        generalPane.setBackground(new java.awt.Color(153, 153, 153));
        exitButton.setText("Exit");
        exitButton.addActionListener(new java.awt.event.ActionListener() {
                                         public void actionPerformed(java.awt.event.ActionEvent evt) {
                                             exitButtonActionPerformed(evt);
                                         }
                                     });

        exitButton.setBounds(110, 30, 100, 23);
        generalPane.add(exitButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        connectButton.setText("Connect");
        connectButton.addActionListener(new java.awt.event.ActionListener() {
                                            public void actionPerformed(java.awt.event.ActionEvent evt) {
                                                connectButtonActionPerformed(evt);
                                            }
                                        });

        connectButton.setBounds(10, 30, 100, 23);
        generalPane.add(connectButton, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel1.setText("Falkon Address");
        jLabel1.setBounds(220, 10, 130, 13);
        generalPane.add(jLabel1, javax.swing.JLayeredPane.DEFAULT_LAYER);

        machName.setText("viper.uchicago.edu");
        machName.setBounds(216, 30, 200, 20);
        generalPane.add(machName, javax.swing.JLayeredPane.DEFAULT_LAYER);

        machPort.setText("50001");
        machPort.setBounds(430, 30, 100, 20);
        generalPane.add(machPort, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel2.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel2.setText("Falkon Port");
        jLabel2.setBounds(430, 10, 80, 13);
        generalPane.add(jLabel2, javax.swing.JLayeredPane.DEFAULT_LAYER);

        securityCheckBox.setText("Security");
        securityCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        securityCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
        securityCheckBox.addActionListener(new java.awt.event.ActionListener() {
                                               public void actionPerformed(java.awt.event.ActionEvent evt) {
                                                   securityCheckBoxActionPerformed(evt);
                                               }
                                           });

        securityCheckBox.setBounds(540, 30, 80, 20);
        generalPane.add(securityCheckBox, javax.swing.JLayeredPane.DEFAULT_LAYER);

        statusText.setEditable(false);
        statusText.setFont(new java.awt.Font("Tahoma", 0, 10));
        statusText.setBounds(10, 80, 720, 20);
        generalPane.add(statusText, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel3.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel3.setText("Status");
        jLabel3.setBounds(10, 60, 110, 13);
        generalPane.add(jLabel3, javax.swing.JLayeredPane.DEFAULT_LAYER);

        pollingInterval.setText("1000");
        pollingInterval.setBounds(630, 30, 100, 20);
        generalPane.add(pollingInterval, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel11.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel11.setText("Polling Interval (ms)");
        jLabel11.setBounds(630, 10, 130, 13);
        generalPane.add(jLabel11, javax.swing.JLayeredPane.DEFAULT_LAYER);

        falkonConfigPane.setBackground(new java.awt.Color(153, 153, 153));
        bundling.setEditable(false);
        bundling.setBounds(10, 50, 100, 20);
        falkonConfigPane.add(bundling, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel13.setFont(new java.awt.Font("Tahoma", 1, 18));
        jLabel13.setText("Falkon Configuration");
        jLabel13.setBounds(0, 0, 200, 22);
        falkonConfigPane.add(jLabel13, javax.swing.JLayeredPane.DEFAULT_LAYER);

        piggyBacking.setEditable(false);
        piggyBacking.setBounds(120, 50, 100, 20);
        falkonConfigPane.add(piggyBacking, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel14.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel14.setText("Max Bundling");
        jLabel14.setBounds(10, 30, 100, 13);
        falkonConfigPane.add(jLabel14, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel15.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel15.setText("Piggy-Backing");
        jLabel15.setBounds(120, 30, 100, 13);
        falkonConfigPane.add(jLabel15, javax.swing.JLayeredPane.DEFAULT_LAYER);

        preFetching.setEditable(false);
        preFetching.setBounds(230, 50, 100, 20);
        falkonConfigPane.add(preFetching, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel16.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel16.setText("Pre-Fetching");
        jLabel16.setBounds(230, 30, 100, 13);
        falkonConfigPane.add(jLabel16, javax.swing.JLayeredPane.DEFAULT_LAYER);

        dataCaching.setEditable(false);
        dataCaching.setBounds(340, 50, 100, 20);
        falkonConfigPane.add(dataCaching, javax.swing.JLayeredPane.DEFAULT_LAYER);

        scheduler.setEditable(false);
        scheduler.setBounds(450, 50, 100, 20);
        falkonConfigPane.add(scheduler, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel21.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel21.setText("Data Caching");
        jLabel21.setBounds(340, 30, 100, 13);
        falkonConfigPane.add(jLabel21, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel22.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel22.setText("Scheduler");
        jLabel22.setBounds(450, 30, 100, 13);
        falkonConfigPane.add(jLabel22, javax.swing.JLayeredPane.DEFAULT_LAYER);

        tasksPane.setBackground(new java.awt.Color(0, 153, 255));
        numQueues.setEditable(false);
        numQueues.setBounds(10, 50, 100, 20);
        tasksPane.add(numQueues, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel23.setFont(new java.awt.Font("Tahoma", 1, 18));
        jLabel23.setText("Tasks");
        jLabel23.setBounds(0, 0, 90, 22);
        tasksPane.add(jLabel23, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel24.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel24.setText("# of Queues");
        jLabel24.setBounds(10, 30, 100, 13);
        tasksPane.add(jLabel24, javax.swing.JLayeredPane.DEFAULT_LAYER);

        waitQlength.setEditable(false);
        waitQlength.setBounds(120, 50, 100, 20);
        tasksPane.add(waitQlength, javax.swing.JLayeredPane.DEFAULT_LAYER);

        activeTasks.setEditable(false);
        activeTasks.setBounds(230, 50, 100, 20);
        tasksPane.add(activeTasks, javax.swing.JLayeredPane.DEFAULT_LAYER);

        deliverQtasks.setEditable(false);
        deliverQtasks.setBounds(340, 50, 100, 20);
        tasksPane.add(deliverQtasks, javax.swing.JLayeredPane.DEFAULT_LAYER);

        deliveredTasks.setEditable(false);
        deliveredTasks.setBounds(450, 50, 100, 20);
        tasksPane.add(deliveredTasks, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel25.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel25.setText("Wait Queue");
        jLabel25.setBounds(120, 30, 100, 13);
        tasksPane.add(jLabel25, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel26.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel26.setText("Active Tasks");
        jLabel26.setBounds(230, 30, 100, 13);
        tasksPane.add(jLabel26, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel27.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel27.setText("Delivery Queue");
        jLabel27.setBounds(340, 30, 100, 13);
        tasksPane.add(jLabel27, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel28.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel28.setText("Delivered Tasks");
        jLabel28.setBounds(450, 30, 100, 13);
        tasksPane.add(jLabel28, javax.swing.JLayeredPane.DEFAULT_LAYER);

        perfPane.setBackground(new java.awt.Color(0, 153, 255));
        submitTP.setEditable(false);
        submitTP.setBounds(10, 50, 100, 20);
        perfPane.add(submitTP, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel29.setFont(new java.awt.Font("Tahoma", 1, 18));
        jLabel29.setText("Performance: Thoughput (tasks/sec)");
        jLabel29.setBounds(0, 0, 350, 22);
        perfPane.add(jLabel29, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel31.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel31.setText("Submit");
        jLabel31.setBounds(10, 30, 100, 13);
        perfPane.add(jLabel31, javax.swing.JLayeredPane.DEFAULT_LAYER);

        dispatchTP.setEditable(false);
        dispatchTP.setBounds(120, 50, 100, 20);
        perfPane.add(dispatchTP, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel32.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel32.setText("Dispatch");
        jLabel32.setBounds(120, 30, 100, 13);
        perfPane.add(jLabel32, javax.swing.JLayeredPane.DEFAULT_LAYER);

        deliveredTP.setEditable(false);
        deliveredTP.setBounds(230, 50, 100, 20);
        perfPane.add(deliveredTP, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel33.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel33.setText("Deliver");
        jLabel33.setBounds(230, 30, 100, 13);
        perfPane.add(jLabel33, javax.swing.JLayeredPane.DEFAULT_LAYER);

        systemPane.setBackground(new java.awt.Color(102, 255, 102));
        numThreads.setEditable(false);
        numThreads.setBounds(10, 50, 100, 20);
        systemPane.add(numThreads, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel30.setFont(new java.awt.Font("Tahoma", 1, 18));
        jLabel30.setText("System");
        jLabel30.setBounds(0, 0, 80, 22);
        systemPane.add(jLabel30, javax.swing.JLayeredPane.DEFAULT_LAYER);

        cpuUtilizationUser.setEditable(false);
        cpuUtilizationUser.setBounds(120, 50, 100, 20);
        systemPane.add(cpuUtilizationUser, javax.swing.JLayeredPane.DEFAULT_LAYER);

        heapFree.setEditable(false);
        heapFree.setBounds(560, 50, 100, 20);
        systemPane.add(heapFree, javax.swing.JLayeredPane.DEFAULT_LAYER);

        heapMax.setEditable(false);
        heapMax.setBounds(670, 50, 100, 20);
        systemPane.add(heapMax, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel34.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel34.setText("# of Threads");
        jLabel34.setBounds(10, 30, 100, 13);
        systemPane.add(jLabel34, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel35.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel35.setText("CPU % (user)");
        jLabel35.setBounds(120, 30, 100, 13);
        systemPane.add(jLabel35, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel36.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel36.setText("Heap Free (MB)");
        jLabel36.setBounds(560, 30, 100, 14);
        systemPane.add(jLabel36, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel37.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel37.setText("Max Heap Size (MB)");
        jLabel37.setBounds(670, 30, 100, 14);
        systemPane.add(jLabel37, javax.swing.JLayeredPane.DEFAULT_LAYER);

        heapSize.setEditable(false);
        heapSize.setBounds(450, 50, 100, 20);
        systemPane.add(heapSize, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel46.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel46.setText("Heap Size (MB)");
        jLabel46.setBounds(450, 30, 100, 14);
        systemPane.add(jLabel46, javax.swing.JLayeredPane.DEFAULT_LAYER);

        cpuUtilizationSystem.setEditable(false);
        cpuUtilizationSystem.setBounds(230, 50, 100, 20);
        systemPane.add(cpuUtilizationSystem, javax.swing.JLayeredPane.DEFAULT_LAYER);

        cpuUtilizationIdle.setEditable(false);
        cpuUtilizationIdle.setBounds(340, 50, 100, 20);
        systemPane.add(cpuUtilizationIdle, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel47.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel47.setText("CPU % (system)");
        jLabel47.setBounds(230, 30, 74, 13);
        systemPane.add(jLabel47, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel48.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel48.setText("CPU % (idle)");
        jLabel48.setBounds(340, 30, 100, 13);
        systemPane.add(jLabel48, javax.swing.JLayeredPane.DEFAULT_LAYER);

        cachingPane.setBackground(new java.awt.Color(255, 102, 102));
        jLabel38.setFont(new java.awt.Font("Tahoma", 1, 18));
        jLabel38.setText("Caching");
        jLabel38.setBounds(0, 0, 150, 22);
        cachingPane.add(jLabel38, javax.swing.JLayeredPane.DEFAULT_LAYER);

        indexSize.setEditable(false);
        indexSize.setBounds(10, 40, 100, 20);
        cachingPane.add(indexSize, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel39.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel39.setText("Index Size");
        jLabel39.setBounds(10, 20, 80, 13);
        cachingPane.add(jLabel39, javax.swing.JLayeredPane.DEFAULT_LAYER);

        cacheHits.setEditable(false);
        cacheHits.setBounds(120, 40, 100, 20);
        cachingPane.add(cacheHits, javax.swing.JLayeredPane.DEFAULT_LAYER);

        cacheMisses.setEditable(false);
        cacheMisses.setBounds(230, 40, 100, 20);
        cachingPane.add(cacheMisses, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel40.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel40.setText("Cache Hits");
        jLabel40.setBounds(120, 20, 47, 13);
        cachingPane.add(jLabel40, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel41.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel41.setText("Cache Misses");
        jLabel41.setBounds(230, 20, 58, 13);
        cachingPane.add(jLabel41, javax.swing.JLayeredPane.DEFAULT_LAYER);

        cacheHitRatio.setEditable(false);
        cacheHitRatio.setBounds(340, 40, 100, 20);
        cachingPane.add(cacheHitRatio, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel42.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel42.setText("Cache Hit Ratio");
        jLabel42.setBounds(340, 20, 100, 13);
        cachingPane.add(jLabel42, javax.swing.JLayeredPane.DEFAULT_LAYER);

        drpConfigPane.setBackground(new java.awt.Color(153, 153, 153));
        jLabel43.setFont(new java.awt.Font("Tahoma", 1, 18));
        jLabel43.setText("DRP Configuration");
        jLabel43.setBounds(0, 0, 240, 22);
        drpConfigPane.add(jLabel43, javax.swing.JLayeredPane.DEFAULT_LAYER);

        drpMinResc.setEditable(false);
        drpMinResc.setBounds(120, 50, 100, 20);
        drpConfigPane.add(drpMinResc, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel17.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel17.setText("DRP Min Resc");
        jLabel17.setBounds(120, 30, 100, 13);
        drpConfigPane.add(jLabel17, javax.swing.JLayeredPane.DEFAULT_LAYER);

        drpMaxResc.setEditable(false);
        drpMaxResc.setBounds(230, 50, 100, 20);
        drpConfigPane.add(drpMaxResc, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel18.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel18.setText("DRP Max Resc");
        jLabel18.setBounds(230, 30, 100, 13);
        drpConfigPane.add(jLabel18, javax.swing.JLayeredPane.DEFAULT_LAYER);

        drpMinTime.setEditable(false);
        drpMinTime.setBounds(340, 50, 120, 20);
        drpConfigPane.add(drpMinTime, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel19.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel19.setText("DRP Min Time (min)");
        jLabel19.setBounds(340, 30, 130, 13);
        drpConfigPane.add(jLabel19, javax.swing.JLayeredPane.DEFAULT_LAYER);

        drpMaxTime.setEditable(false);
        drpMaxTime.setBounds(480, 50, 120, 20);
        drpConfigPane.add(drpMaxTime, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel20.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel20.setText("DRP Max Time (min)");
        jLabel20.setBounds(480, 30, 130, 13);
        drpConfigPane.add(jLabel20, javax.swing.JLayeredPane.DEFAULT_LAYER);

        drpAllocation.setEditable(false);
        drpAllocation.setBounds(10, 50, 100, 20);
        drpConfigPane.add(drpAllocation, javax.swing.JLayeredPane.DEFAULT_LAYER);

        drpIdle.setEditable(false);
        drpIdle.setBounds(620, 50, 120, 20);
        drpConfigPane.add(drpIdle, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel44.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel44.setText("DRP Allocation");
        jLabel44.setBounds(10, 30, 100, 13);
        drpConfigPane.add(jLabel44, javax.swing.JLayeredPane.DEFAULT_LAYER);

        jLabel45.setFont(new java.awt.Font("Tahoma", 0, 10));
        jLabel45.setText("DRP De-Allocation Idle (sec)");
        jLabel45.setBounds(620, 30, 190, 13);
        drpConfigPane.add(jLabel45, javax.swing.JLayeredPane.DEFAULT_LAYER);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                                 layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                 .add(layout.createSequentialGroup()
                                      .addContainerGap()
                                      .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                           .add(jLabel4, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 773, Short.MAX_VALUE)
                                           .add(falkonConfigPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 773, Short.MAX_VALUE)
                                           .add(generalPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 773, Short.MAX_VALUE)
                                           .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel5, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 773, Short.MAX_VALUE)
                                           .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                                                .add(org.jdesktop.layout.GroupLayout.LEADING, systemPane)
                                                .add(org.jdesktop.layout.GroupLayout.LEADING, cachingPane)
                                                .add(org.jdesktop.layout.GroupLayout.LEADING, perfPane)
                                                .add(org.jdesktop.layout.GroupLayout.LEADING, tasksPane)
                                                .add(org.jdesktop.layout.GroupLayout.LEADING, resourcePane)
                                                .add(org.jdesktop.layout.GroupLayout.LEADING, drpConfigPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 773, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                                      .addContainerGap())
                                 );
        layout.setVerticalGroup(
                               layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                               .add(layout.createSequentialGroup()
                                    .addContainerGap()
                                    .add(jLabel4)
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(jLabel5)
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(generalPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 112, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(falkonConfigPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 81, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(drpConfigPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 73, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(resourcePane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 83, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(tasksPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(perfPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 81, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(cachingPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 72, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(systemPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 84, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                               );
        pack();
    }// </editor-fold>

    private void securityCheckBoxActionPerformed(java.awt.event.ActionEvent evt)
    {//GEN-FIRST:event_securityCheckBoxActionPerformed
// TODO add your handling code here:
    }//GEN-LAST:event_securityCheckBoxActionPerformed

    private void exitButtonActionPerformed(java.awt.event.ActionEvent evt)
    {//GEN-FIRST:event_exitButtonActionPerformed
// TODO add your handling code here:
        System.out.println("User clicked on the exit button, exiting!");
        System.exit(0);
    }//GEN-LAST:event_exitButtonActionPerformed

    public String isSecure()
    {
        if (securityCheckBox.isSelected())
            return "enabled";
        else
            return "disabled";
    }

    private void connectButtonActionPerformed(java.awt.event.ActionEvent evt)
    {//GEN-FIRST:event_connectButtonActionPerformed
// TODO add your handling code here:
        Calendar cal = new GregorianCalendar();
        statusText.setText("[" + cal.getTime() + "] Connecting to " + machName.getText() + " on port " + machPort.getText() + " with security " + isSecure() + "...");

        if (connectToFalkon()) {

            int delay = 0;   // delay for 5 sec.
            int period = 1000;
            try {

                period = Integer.parseInt(pollingInterval.getText());  // repeat every sec.
            } catch (Exception e) {
                e.printStackTrace();
            }
            Timer timer = new Timer();

            timer.scheduleAtFixedRate(new TimerTask()
                                      {
                                          public void run()
                                          {
                                              runMonitor();
                                              // Task here ...
                                          }
                                      }, delay, period);
        } else {
            cal = new GregorianCalendar();
            statusText.setText("[" + cal.getTime() + "] Failed to connect to " + machName.getText() + " on port " + machPort.getText() + " with security " + isSecure() + "... exiting!");

            try {
                Thread.sleep(5000);
            } catch (Exception e) {
                e.printStackTrace();
            }

            System.out.println("Failed to connect to " + machName.getText() + " on port " + machPort.getText() + " with security " + isSecure() + "... exiting!");
            System.exit(0);
        }





    }//GEN-LAST:event_connectButtonActionPerformed


    public boolean writeLogUserTest = true;
    public BufferedWriter outLog = null;

    public synchronized void writeLog(MonitorConfigResponse mcr, MonitorStateResponse msr)
    {

        if (writeLogUserTest) {
            try {
                if (outLog == null) {
                    String outUserFileName = "monitor.log";

                    outLog = new BufferedWriter(new FileWriter(outUserFileName, false));
                    outLog.write("CONFIG: Time_ms MaxBundling PiggyBacking PreFetching DrpAllocation DrpMinResc DrpMaxResc DrpMinTime DrpMaxTime DrpIdle Scheduler DataCaching\n");

                    if (mcr != null && mcr.isValid()) {
                        outLog.write("CONFIG: ");
                        outLog.write(System.currentTimeMillis() + " ");
                        outLog.write(mcr.getMaxBundling() + " ");
                        outLog.write(mcr.isPiggyBacking() + " ");
                        outLog.write(mcr.isPreFetching() + " ");
                        outLog.write(mcr.getDrpAllocation() + " ");
                        outLog.write(mcr.getDrpMinResc() + " ");
                        outLog.write(mcr.getDrpMaxResc() + " ");
                        outLog.write(mcr.getDrpMinTime() + " ");
                        outLog.write(mcr.getDrpMaxTime() + " ");
                        outLog.write(mcr.getDrpIdle() + " ");
                        outLog.write(mcr.getScheduler() + " ");
                        outLog.write(mcr.isDataCaching() + "\n");

                    }


                    outLog.write("STATE: Time_ms ResourceAllocated ResourceRegistered ResourceFree ResourcePending ResourceActive TaskNumQueues TaskSubmit TaskWaitQueue TaskDispatch TaskActive TaskDeliveryQueue TaskDelivered CacheSize CacheHits CacheMisses SystemNumThreads SystemCPUuser SystemCPUsystem SystemCPUidle SystemHeapSize SystemHeapFree SystemHeapMax SubmitTP DispatchTP DeliverTP \n");

                }



                if (msr != null && msr.isValid()) {
                    outLog.write("STATE: ");

                    outLog.write(System.currentTimeMillis() + " ");
                    outLog.write(msr.getResourceAllocated() + " ");
                    outLog.write(msr.getResourceRegistered() + " ");
                    outLog.write(msr.getResourceFree() + " ");
                    outLog.write(msr.getResourcePending() + " ");
                    outLog.write(msr.getResourceActive() + " ");
                    outLog.write(msr.getTaskNumQueues() + " ");
                    outLog.write(msr.getTaskSubmit() + " ");
                    outLog.write(msr.getTaskWaitQueue() + " ");
                    outLog.write(msr.getTaskDispatch() + " ");
                    outLog.write(msr.getTaskActive() + " ");
                    outLog.write(msr.getTaskDeliveryQueue() + " ");
                    outLog.write(msr.getTaskDelivered() + " ");
                    outLog.write(msr.getCacheSize() + " ");
                    outLog.write(msr.getCacheHitsGlobal() + " ");
                    outLog.write(msr.getCacheHitsLocal() + " ");
                    outLog.write(msr.getCacheMisses() + " ");
                    outLog.write(msr.getSystemNumThreads() + " ");
                    outLog.write(msr.getSystemCPUuser() + " ");
                    outLog.write(msr.getSystemCPUsystem() + " ");
                    outLog.write(msr.getSystemCPUidle() + " ");
                    outLog.write(msr.getSystemHeapSize() + " ");
                    outLog.write(msr.getSystemHeapFree() + " ");
                    outLog.write(msr.getSystemHeapMax() + " ");
                }

                //outLog.write(System.currentTimeMillis() + " " + userMap.size() + " " + resourceSet.size() + " " + Thread.activeCount() + " " + getWaitingTasks() + " " + getActiveTasks() + " " + getDoneTasks() + " " + getDeliveredTasks() + "\n");
                outLog.flush();

                //outWorker.close();
            } catch (IOException e) {
                System.out.println("Error in writeLogUser() when trying to log message: " + e);
                e.printStackTrace();
            }
        }

    }

    public boolean firstTime = true;

    public long startTime = 0;

    public synchronized void displayStatusText(MonitorConfigResponse mcr, MonitorStateResponse msr)
    {

        try {
            //String outUserFileName = "monitor.log";

            //outLog = new BufferedWriter(new FileWriter(outUserFileName, false));
            if (firstTime) {

                System.out.print("WallTime_ms ElapsedTime_sec MaxBundling PiggyBacking PreFetching DrpAllocation DrpMinResc DrpMaxResc DrpMinTime DrpMaxTime DrpIdle Scheduler DataCaching ResourceAllocated ResourceRegistered ResourceFree ResourcePending ResourceActive TaskNumQueues TaskSubmit TaskWaitQueue TaskDispatch TaskActive TaskDeliveryQueue TaskDelivered CacheSize getCacheHitsGlobal getCacheHitsLocal CacheMisses SystemNumThreads SystemCPUuser SystemCPUsystem SystemCPUidle SystemHeapSize SystemHeapFree SystemHeapMax SubmitTP DispatchTP DeliverTP \n");
                firstTime = false;
                startTime = System.currentTimeMillis();
            }
            if (mcr != null && mcr.isValid() && msr != null && msr.isValid()) {

                //compute TP on these values...
                int taskSubmit = msr.getTaskSubmit();
                int taskDispatch = msr.getTaskDispatch();
                int taskDelivered = msr.getTaskDelivered();
                long curTime = System.currentTimeMillis();
                double submitTP = 0;
                double dispatchTP = 0;
                double deliverTP = 0;


                double elapsedTime = (curTime - curTimeOld)*1.0/1000.0;

                if (elapsedTime > 0) {
                    submitTP = (taskSubmit - taskSubmitOld)*1.0/elapsedTime;
                    dispatchTP = (taskDispatch - taskDispatchOld)*1.0/elapsedTime;
                    deliverTP = (taskDelivered - taskDeliveredOld)*1.0/elapsedTime;

                    //submitTP.setText((new Double(submitTPd)).toString());
                    //dispatchTP.setText((new Double(dispatchTPd)).toString());
                    //deliveredTP.setText((new Double(deliverTPd)).toString());

                    //displayPerfText(submitTPd, dispatchTPd, deliverTPd);
                }
                //else
                //{

                //submitTP.setText("0.0");
                //dispatchTP.setText("0.0");
                //deliveredTP.setText("0.0");
                //}

                taskSubmitOld = taskSubmit;
                taskDispatchOld = taskDispatch;
                taskDeliveredOld = taskDelivered;
                curTimeOld = curTime;




                //System.out.print("CONFIG: ");
                System.out.print(System.currentTimeMillis() + " ");
                System.out.print((System.currentTimeMillis() - startTime)*1.0/1000.0 + " ");
                System.out.print(mcr.getMaxBundling() + " ");
                System.out.print(mcr.isPiggyBacking() + " ");
                System.out.print(mcr.isPreFetching() + " ");
                System.out.print(mcr.getDrpAllocation() + " ");
                System.out.print(mcr.getDrpMinResc() + " ");
                System.out.print(mcr.getDrpMaxResc() + " ");
                System.out.print(mcr.getDrpMinTime() + " ");
                System.out.print(mcr.getDrpMaxTime() + " ");
                System.out.print(mcr.getDrpIdle() + " ");
                System.out.print(mcr.getScheduler() + " ");
                System.out.print(mcr.isDataCaching() + " ");

                //System.out.print(System.currentTimeMillis() + " ");
                System.out.print(msr.getResourceAllocated() + " ");
                System.out.print(msr.getResourceRegistered() + " ");
                System.out.print(msr.getResourceFree() + " ");
                System.out.print(msr.getResourcePending() + " ");
                System.out.print(msr.getResourceActive() + " ");
                System.out.print(msr.getTaskNumQueues() + " ");
                System.out.print(msr.getTaskSubmit() + " ");
                System.out.print(msr.getTaskWaitQueue() + " ");
                System.out.print(msr.getTaskDispatch() + " ");
                System.out.print(msr.getTaskActive() + " ");
                System.out.print(msr.getTaskDeliveryQueue() + " ");
                System.out.print(msr.getTaskDelivered() + " ");
                System.out.print(msr.getCacheSize() + " ");
                System.out.print(msr.getCacheHitsGlobal() + " ");
                System.out.print(msr.getCacheHitsLocal() + " ");
                System.out.print(msr.getCacheMisses() + " ");
                System.out.print(msr.getSystemNumThreads() + " ");
                System.out.print(msr.getSystemCPUuser() + " ");
                System.out.print(msr.getSystemCPUsystem() + " ");
                System.out.print(msr.getSystemCPUidle() + " ");
                System.out.print(msr.getSystemHeapSize() + " ");
                System.out.print(msr.getSystemHeapFree() + " ");
                System.out.print(msr.getSystemHeapMax() + " ");

                System.out.print(submitTP + " ");
                System.out.print(dispatchTP + " ");
                System.out.print(deliverTP + "\n");
            }

            //outLog.write(System.currentTimeMillis() + " " + userMap.size() + " " + resourceSet.size() + " " + Thread.activeCount() + " " + getWaitingTasks() + " " + getActiveTasks() + " " + getDoneTasks() + " " + getDeliveredTasks() + "\n");

            //outWorker.close();
        } catch (Exception e) {
            System.out.println("Error in getting status info: " + e);
            e.printStackTrace();
        }


    }

    public synchronized void displayStatusTextUI(MonitorConfigResponse mcr, MonitorStateResponse msr)
    {

        try {
            //String outUserFileName = "monitor.log";

            //outLog = new BufferedWriter(new FileWriter(outUserFileName, false));
            if (firstTime) {

                firstTime = false;
                startTime = System.currentTimeMillis();
            }
            if (mcr != null && mcr.isValid() && msr != null && msr.isValid()) {
                System.out.print((char)27 + "[2J");
                //System.out.print("\f");



                //compute TP on these values...
                int taskSubmit = msr.getTaskSubmit();
                int taskDispatch = msr.getTaskDispatch();
                int taskDelivered = msr.getTaskDelivered();
                long curTime = System.currentTimeMillis();

                double submitTP = 0;
                double dispatchTP = 0;
                double deliverTP = 0;


                double elapsedTime = (curTime - curTimeOld)*1.0/1000.0;

                if (elapsedTime > 0) {
                    submitTP = (taskSubmit - taskSubmitOld)*1.0/elapsedTime;
                    dispatchTP = (taskDispatch - taskDispatchOld)*1.0/elapsedTime;
                    deliverTP = (taskDelivered - taskDeliveredOld)*1.0/elapsedTime;

                    //submitTP.setText((new Double(submitTPd)).toString());
                    //dispatchTP.setText((new Double(dispatchTPd)).toString());
                    //deliveredTP.setText((new Double(deliverTPd)).toString());

                    //displayPerfText(submitTPd, dispatchTPd, deliverTPd);
                }
                //else
                //{

                //submitTP.setText("0.0");
                //dispatchTP.setText("0.0");
                //deliveredTP.setText("0.0");
                //}

                taskSubmitOld = taskSubmit;
                taskDispatchOld = taskDispatch;
                taskDeliveredOld = taskDelivered;
                curTimeOld = curTime;




                //System.out.print("CONFIG: ");
                System.out.println("WallTime_ms: " + System.currentTimeMillis() + " ");
                System.out.println("ElapsedTime_sec: " + (System.currentTimeMillis() - startTime)*1.0/1000.0 + " ");
                System.out.println("MaxBundling: " + mcr.getMaxBundling() + " ");
                System.out.println("PiggyBacking: " + mcr.isPiggyBacking() + " ");
                System.out.println("PreFetching: " + mcr.isPreFetching() + " ");
                System.out.println("DrpAllocation: " + mcr.getDrpAllocation() + " ");
                System.out.println("DrpMinResc: " + mcr.getDrpMinResc() + " ");
                System.out.println("DrpMaxResc: " + mcr.getDrpMaxResc() + " ");
                System.out.println("DrpMinTime: " + mcr.getDrpMinTime() + " ");
                System.out.println("DrpMaxTime: " + mcr.getDrpMaxTime() + " ");
                System.out.println("DrpIdle: " + mcr.getDrpIdle() + " ");
                System.out.println("Scheduler: " + mcr.getScheduler() + " ");
                System.out.println("DataCaching: " + mcr.isDataCaching() + " ");

                System.out.println("ResourceAllocated: " + msr.getResourceAllocated() + " ");
                System.out.println("ResourceRegistered: " + msr.getResourceRegistered() + " ");
                System.out.println("ResourceFree: " + msr.getResourceFree() + " ");
                System.out.println("ResourcePending: " + msr.getResourcePending() + " ");
                System.out.println("ResourceActive: " + msr.getResourceActive() + " ");
                System.out.println("TaskNumQueues: " + msr.getTaskNumQueues() + " ");
                System.out.println("TaskSubmit: " + msr.getTaskSubmit() + " ");
                System.out.println("TaskWaitQueue: " + msr.getTaskWaitQueue() + " ");
                System.out.println("TaskDispatch: " + msr.getTaskDispatch() + " ");
                System.out.println("TaskActive: " + msr.getTaskActive() + " ");
                System.out.println("TaskDeliveryQueue: " + msr.getTaskDeliveryQueue() + " ");
                System.out.println("TaskDelivered: " + msr.getTaskDelivered() + " ");
                System.out.println("CacheSize: " + msr.getCacheSize() + " ");
                System.out.println("CacheHitsGlobal: " + msr.getCacheHitsGlobal() + " ");
                System.out.println("CacheHitsLocal: " + msr.getCacheHitsLocal() + " ");
                System.out.println("CacheMisses: " + msr.getCacheMisses() + " ");
                System.out.println("SystemNumThreads: " + msr.getSystemNumThreads() + " ");
                System.out.println("SystemCPUuser: " + msr.getSystemCPUuser() + " ");
                System.out.println("SystemCPUsystem: " + msr.getSystemCPUsystem() + " ");
                System.out.println("SystemCPUidle: " + msr.getSystemCPUidle() + " ");
                System.out.println("SystemHeapSize: " + msr.getSystemHeapSize() + " ");
                System.out.println("SystemHeapFree: " + msr.getSystemHeapFree() + " ");
                System.out.println("SystemHeapMax: " + msr.getSystemHeapMax() + " ");

                System.out.println("SubmitTP: " + submitTP + " ");
                System.out.println("DispatchTP: " + dispatchTP + " ");
                System.out.println("DeliverTP: " + deliverTP + " ");
            }

            //outLog.write(System.currentTimeMillis() + " " + userMap.size() + " " + resourceSet.size() + " " + Thread.activeCount() + " " + getWaitingTasks() + " " + getActiveTasks() + " " + getDoneTasks() + " " + getDeliveredTasks() + "\n");

            //outWorker.close();
        } catch (Exception e) {
            System.out.println("Error in getting status info: " + e);
            e.printStackTrace();
        }


    }


    public synchronized void writeLogPerf(double submitTP, double dispatchTP, double deliverTP)
    {

        if (writeLogUserTest) {
            try {
                if (outLog != null) {
                    outLog.write(submitTP + " ");
                    outLog.write(dispatchTP + " ");
                    outLog.write(deliverTP + "\n");
                }

                //outLog.write(System.currentTimeMillis() + " " + userMap.size() + " " + resourceSet.size() + " " + Thread.activeCount() + " " + getWaitingTasks() + " " + getActiveTasks() + " " + getDoneTasks() + " " + getDeliveredTasks() + "\n");
                outLog.flush();

                //outWorker.close();
            } catch (IOException e) {
                System.out.println("Error in writeLogUser() when trying to log message: " + e);
                e.printStackTrace();
            }
        }

    }



    public FalkonMonitor fMonitor = null;

    public void runMonitor()
    {
        MonitorStateResponse sr = null;
        if (fMonitor != null)
            sr = fMonitor.getMonitorState();
        else {
            System.out.println("fMonitor == null, will soon exit...");

        }

        if (sr != null) {


            writeLog(null, sr);
            //sr = fMonitor.getState();
            updateStatus(sr);
            //updateConfig(sr);
            updateResources(sr);
            updateTasks(sr);
            updatePerformance(sr);
            updateCache(sr);
            updateSystem(sr);
        } else {
            Calendar cal = new GregorianCalendar();

            cal = new GregorianCalendar();
            statusText.setText("[" + cal.getTime() + "] Failed to retrieve Falkon's state... exiting!");

            try {
                Thread.sleep(5000);
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println("StatusResponse == null, exiting!");
            System.exit(0);
        }
    }

    

    public void runMonitorTextGetWorkersTasks()
    {
        MonitorWorkerStateResponse swr = null;
        MonitorTaskStateResponse str = null;
        if (fMonitor != null) {

            swr = fMonitor.getMonitorWorkerState();
            str = fMonitor.getMonitorTaskState();
        } else {
            System.out.println("fMonitor == null, exiting...");

        }




        if (swr != null) 
        {
            if (swr.getFreeWorkerNum() > 0)
            {
                String array[] = swr.getFreeWorkers();
                if (array != null && array.length > 0)
                {
                    System.out.println(array.length + " free workers...");
                    for (int i=0;i<array.length;i++)
                    {
                        System.out.println("["+i+"]: " + array[i]);

                    }
                }
                else
                {
                    System.out.println("0 free workers...");

                }
            }
            else
            {
                System.out.println("0 free workers...");

            }
            System.out.println("");


            if (swr.getPendWorkerNum() > 0)
            {
                String array[] = swr.getPendWorkers();
                if (array != null && array.length > 0)
                {
                    System.out.println(array.length + " pending workers...");
                    for (int i=0;i<array.length;i++)
                    {
                        System.out.println("["+i+"]: " + array[i]);

                    }
                }
                else
                {
                    System.out.println("0 pending workers...");

                }
            }
            else
            {
                System.out.println("0 pending workers...");

            }
            System.out.println("");



            if (swr.getBusyWorkerNum() > 0)
            {
                String array[] = swr.getBusyWorkers();
                if (array != null && array.length > 0)
                {
                    System.out.println(array.length + " busy workers...");
                    for (int i=0;i<array.length;i++)
                    {
                        System.out.println("["+i+"]: " + array[i]);

                    }
                }
                else
                {
                    System.out.println("0 busy workers...");

                }
            }
            else
            {
                System.out.println("0 busy workers...");

            }
            System.out.println("");
            
        } 
        if (str != null)
        {

            if (str.getQueuedTaskNum() > 0)
            {
                String array[] = str.getQueuedTasks();
                if (array != null && array.length > 0)
                {
                    System.out.println(array.length + " queued tasks...");
                    for (int i=0;i<array.length;i++)
                    {
                        System.out.println("["+i+"]: " + array[i]);

                    }
                }
                else
                {
                    System.out.println("0 queued tasks...");

                }
            }
            else
            {
                System.out.println("0 queued tasks...");

            }
            System.out.println("");


            if (str.getActiveTaskNum() > 0)
            {
                String array[] = str.getActiveTasks();
                if (array != null && array.length > 0)
                {
                    System.out.println(array.length + " active tasks...");
                    for (int i=0;i<array.length;i++)
                    {
                        System.out.println("["+i+"]: " + array[i]);

                    }
                }
                else
                {
                    System.out.println("0 active tasks...");

                }
            }
            else
            {
                System.out.println("0 active tasks...");

            }
            System.out.println("");



            if (str.getDoneTaskNum() > 0)
            {
                String array[] = str.getDoneTasks();
                if (array != null && array.length > 0)
                {
                    System.out.println(array.length + " done tasks...");
                    for (int i=0;i<array.length;i++)
                    {
                        System.out.println("["+i+"]: " + array[i]);

                    }
                }
                else
                {
                    System.out.println("0 done tasks...");

                }
            }
            else
            {
                System.out.println("0 done tasks...");

            }
            System.out.println("");
        }
        //else {
        //    System.out.println("StatusResponse == null, exiting!");
            System.exit(0);
        //}
    }


    public void runMonitorText()
    {
        MonitorStateResponse sr = null;
        MonitorConfigResponse mcr = null;
        if (fMonitor != null) {

            sr = fMonitor.getMonitorState();
            mcr = fMonitor.getMonitorConfig();
        } else {
            System.out.println("fMonitor == null, will soon exit...");

        }




        if (mcr != null && sr != null) {

            if (MODE_TEXT) {

                displayStatusText(mcr, sr);
            } else {
                displayStatusTextUI(mcr, sr);

            }
            //updatePerformanceText(sr);
            //sr = fMonitor.getState();
            //updateStatus(sr);
            //updateConfig(sr);
            //updateResources(sr);
            //updateTasks(sr);
            //updatePerformance(sr);
            //updateCache(sr);
            //updateSystem(sr);
        } else {
            System.out.println("StatusResponse == null, exiting!");
            System.exit(-1);
        }
    }


    public boolean connectToFalkon()
    {
        System.out.println("Connecting to Falkon service...");

        fMonitor = new FalkonMonitor(DEBUG);
        //System.out.println("DIPERF=" + worker.DIPERF);

        String securityFile = new String("etc/client-security-config.xml");
        String serviceURI = null;
        if (securityCheckBox.isSelected()) {
            serviceURI = new String("https://" + machName.getText() + ":" + machPort.getText() + "/wsrf/services/GenericPortal/core/WS/GPFactoryService");
        } else
            serviceURI = new String("http://" + machName.getText() + ":" + machPort.getText() + "/wsrf/services/GenericPortal/core/WS/GPFactoryService");

        //fMonitor.parseArgs(args);
        boolean createTest = fMonitor.createResource(securityFile, serviceURI);

        MonitorConfigResponse mcr = fMonitor.getMonitorConfig();


        if (createTest && mcr.isValid()) {

            String msg = new String(" state retrieved successful!");
            Calendar cal = new GregorianCalendar();
            statusText.setText("[" + cal.getTime() + "] Connected to " + machName.getText() + " on port " + machPort.getText() + " with security " + isSecure() + "... polling every " + pollingInterval.getText() + " ms: " + msg);


            writeLog(mcr, null);
            updateConfig(mcr);

            return true;
        } else

            return false;

    }

    public boolean connectToFalkonText()
    {
        System.out.println("Connecting to Falkon service...");

        fMonitor = new FalkonMonitor(DEBUG);
        //System.out.println("DIPERF=" + worker.DIPERF);

        String securityFile = new String(CLIENT_DESC);

        //fMonitor.parseArgs(args);
        return fMonitor.createResource(securityFile, serviceURI);

    }


    public void updateStatus(MonitorStateResponse sr)
    {
        try {
            String msg = new String("");
            if (sr.isValid()) {
                msg = "state retrieved successful!";

            } else
                msg = "state retrieved failed!";

            Calendar cal = new GregorianCalendar();
            statusText.setText("[" + cal.getTime() + "] Connected to " + machName.getText() + " on port " + machPort.getText() + " with security " + isSecure() + "... polling every " + pollingInterval.getText() + " ms: " + msg);
            //Thread.sleep(Integer.parseInt(pollingInterval.getText()));
        } catch (Exception e) {
            e.printStackTrace();

        }

    }

    public void updateConfig(MonitorConfigResponse mcr)
    {

        if (mcr.isValid()) {

            bundling.setText((new Integer(mcr.getMaxBundling())).toString());
            if (mcr.isPiggyBacking())
                piggyBacking.setText("enabled");
            else
                piggyBacking.setText("disabled");

            if (mcr.isPreFetching())
                preFetching.setText("enabled");
            else
                preFetching.setText("disabled");

            drpAllocation.setText(mcr.getDrpAllocation());


            drpMinResc.setText((new Integer(mcr.getDrpMinResc())).toString());
            drpMaxResc.setText((new Integer(mcr.getDrpMaxResc())).toString());
            drpMinTime.setText((new Integer(mcr.getDrpMinTime())).toString());
            drpMaxTime.setText((new Integer(mcr.getDrpMaxTime())).toString());
            drpIdle.setText((new Integer(mcr.getDrpIdle())).toString());

            if (mcr.isDataCaching())
                dataCaching.setText("enabled");
            else
                dataCaching.setText("disabled");

            scheduler.setText(mcr.getScheduler());
        }
    }

    public void updateResources(MonitorStateResponse sr)
    {
        if (sr.isValid()) {

            allocatedExecutors.setText((new Integer(sr.getResourceAllocated())).toString());
            registeredExecutors.setText((new Integer(sr.getResourceRegistered())).toString());
            freeExecutors.setText((new Integer(sr.getResourceFree())).toString());
            pendingExecutors.setText((new Integer(sr.getResourcePending())).toString());
            activeExecutors.setText((new Integer(sr.getResourceActive())).toString());
        }
    }

    public void updateTasks(MonitorStateResponse sr)
    {

        if (sr.isValid()) {
            numQueues.setText((new Integer(sr.getTaskNumQueues())).toString());
            waitQlength.setText((new Integer(sr.getTaskWaitQueue())).toString());
            activeTasks.setText((new Integer(sr.getTaskActive())).toString());
            deliverQtasks.setText((new Integer(sr.getTaskDeliveryQueue())).toString());
            deliveredTasks.setText((new Integer(sr.getTaskDelivered())).toString());


        }
    }


    public int taskSubmitOld = 0;
    public int taskDispatchOld = 0;
    public int taskDeliveredOld = 0;
    public long curTimeOld = System.currentTimeMillis();


    public void updatePerformance(MonitorStateResponse sr)
    {

        if (sr.isValid()) {
            //compute TP on these values...
            int taskSubmit = sr.getTaskSubmit();
            int taskDispatch = sr.getTaskDispatch();
            int taskDelivered = sr.getTaskDelivered();
            long curTime = System.currentTimeMillis();

            double elapsedTime = (curTime - curTimeOld)*1.0/1000.0;

            if (elapsedTime > 0) {
                double submitTPd = (taskSubmit - taskSubmitOld)*1.0/elapsedTime;
                double dispatchTPd = (taskDispatch - taskDispatchOld)*1.0/elapsedTime;
                double deliverTPd = (taskDelivered - taskDeliveredOld)*1.0/elapsedTime;

                submitTP.setText((new Double(submitTPd)).toString());
                dispatchTP.setText((new Double(dispatchTPd)).toString());
                deliveredTP.setText((new Double(deliverTPd)).toString());

                writeLogPerf(submitTPd, dispatchTPd, deliverTPd);
            } else {

                submitTP.setText("0.0");
                dispatchTP.setText("0.0");
                deliveredTP.setText("0.0");
            }

            taskSubmitOld = taskSubmit;
            taskDispatchOld = taskDispatch;
            taskDeliveredOld = taskDelivered;
            curTimeOld = curTime;


        }
    }



    public void updateCache(MonitorStateResponse sr)
    {
        if (sr.isValid()) {
            indexSize.setText((new Integer(sr.getCacheSize())).toString());

            int cacheHitsInt = sr.getCacheHitsLocal();
            int cacheHitsIntGlobal = sr.getCacheHitsGlobal();
            int cacheMissesInt = sr.getCacheMisses();


            cacheHits.setText((new Integer(cacheHitsInt)).toString());
            cacheMisses.setText((new Integer(cacheMissesInt)).toString());

            if (cacheHitsInt + cacheMissesInt > 0) {
                cacheHitRatio.setText((new Double(cacheHitsInt*1.0/(cacheHitsInt + cacheMissesInt))).toString());
            } else
                cacheHitRatio.setText("0.0");

        }
    }


    public void updateSystem(MonitorStateResponse sr)
    {

        if (sr.isValid()) {
            numThreads.setText((new Integer(sr.getSystemNumThreads())).toString());
            cpuUtilizationUser.setText((new Integer(sr.getSystemCPUuser())).toString()+"%");
            cpuUtilizationSystem.setText((new Integer(sr.getSystemCPUsystem())).toString()+"%");
            cpuUtilizationIdle.setText((new Integer(sr.getSystemCPUidle())).toString()+"%");
            heapSize.setText((new Integer(sr.getSystemHeapSize())).toString()+"MB");
            heapFree.setText((new Integer(sr.getSystemHeapFree())).toString()+"MB");
            heapMax.setText((new Integer(sr.getSystemHeapMax())).toString()+"MB");
        }
    }


    public String FALKON_MONITOR_HOME = null;

    public boolean GET_WORKERS_TASKS = false;
    public boolean MODE_GUI = true;
    public boolean MODE_TEXT = false;
    public boolean MODE_TEXT_UI = false;

    public void parseArgs(String[] args) throws Exception
    {
        if (args.length < 1) {
            usage(args);
            return;
        }

        Properties props = System.getProperties();
        FALKON_MONITOR_HOME = (String)props.get("FALKON_MONITOR_HOME");
        if (FALKON_MONITOR_HOME == null) {
            FALKON_MONITOR_HOME = new String("");
            System.out.println("Warning, ${FALKON_MONITOR_HOME} is not set, you must include -DFALKON_MONITOR_HOME=${FALKON_MONITOR_HOME} when starting the JVM...  things might not work due to relative path names...");

        }


        int ctr;
        for (ctr = 0; ctr < args.length; ctr++) {
            if (args[ctr].equals("-serviceURI") && ctr + 1 < args.length) {
                ctr++;
                serviceURI = new String(args[ctr]);
                //System.out.println("Setting serviceURI to " + serviceURI);
            }

            else if (args[ctr].equals("-monitor") && ctr + 1 < args.length) {
                ctr++;
                pollTime = Long.parseLong(args[ctr]); //in minutes
            } else if (args[ctr].equals("-debug")) {//&& ctr + 1 < args.length)
                DEBUG = true;
            } else if (args[ctr].equals("-diperf")) {//&& ctr + 1 < args.length)
                DIPERF = true;

            } else if (args[ctr].equals("-mode_gui")) {//&& ctr + 1 < args.length)
                GET_WORKERS_TASKS = false;
                MODE_GUI = true;
                MODE_TEXT = false;
                MODE_TEXT_UI = false;


            }else if (args[ctr].equals("-get_workers_tasks")) {//&& ctr + 1 < args.length)
                GET_WORKERS_TASKS = true;
                MODE_GUI = false;
                MODE_TEXT = false;
                MODE_TEXT_UI = false;


            } else if (args[ctr].equals("-mode_text")) {//&& ctr + 1 < args.length)
                GET_WORKERS_TASKS = false;
                MODE_GUI = false;
                MODE_TEXT = true;
                MODE_TEXT_UI = false;


            } else if (args[ctr].equals("-mode_text_ui")) {//&& ctr + 1 < args.length)
                GET_WORKERS_TASKS = false;
                MODE_GUI = false;
                MODE_TEXT = false;
                MODE_TEXT_UI = true;


            }


            else if (args[ctr].equals("-CLIENT_DESC") && ctr + 1 < args.length) {
                ctr++;
                CLIENT_DESC = new String(args[ctr]);
            } else if (args[ctr].equals("-help")) {//&& ctr + 1 < args.length)
                if (DEBUG) if (DIPERF == false) System.out.println("Help Screen:");
                usage(args);

            } else {

                if (DIPERF == false) {
                    System.out.println("ERROR: invalid parameter - " + args[ctr] + " at arguement " + ctr + " of " + args.length + " arguements");
                    System.out.println("Current parameters values:");
                    System.out.println("-serviceURI " + serviceURI);
                    System.out.println("-debug " + DEBUG);
                    System.out.println("-diperf " + DIPERF);
                }

                usage(args);
            }
        }

    }

    public void usage(String[] args)
    {
        if (DIPERF == false) {
            System.out.println("Help Screen: ");
            System.out.println("-diperf <>");
            System.out.println("-help <>");
        }
        System.exit(0);

    }

    public void main_run(String[] args) throws Exception
    {
        if (connectToFalkonText()) {

            int delay = 0;   // delay for 5 sec.
            int period = (int)pollTime;
            Timer timer = new Timer();

            timer.scheduleAtFixedRate(new TimerTask()
                                      {
                                          public void run()
                                          {
                                              runMonitorText();
                                              // Task here ...
                                          }
                                      }, delay, period);
        } else {

            System.out.println("Failed to connect to " + machName.getText() + " on port " + machPort.getText() + " with security " + isSecure() + "... exiting!");
            System.exit(-1);
        }




        //}

    }

    public void main_run_once(String[] args) throws Exception
    {
        if (connectToFalkonText()) {

            int delay = 0;   // delay for 5 sec.
            //int period = (int)pollTime;
            Timer timer = new Timer();

            timer.schedule(new TimerTask()
                                      {
                                          public void run()
                                          {
                                              runMonitorTextGetWorkersTasks();
                                              // Task here ...
                                          }
                                      }, delay);
        } else {

            System.out.println("Failed to connect to " + machName.getText() + " on port " + machPort.getText() + " with security " + isSecure() + "... exiting!");
            System.exit(-1);
        }




        //}

    }


    /**
     * @param args the command line arguments
     */
    public static void main(String args[])
    {

        try {
            StopWatch all = new StopWatch();
            StopWatch sw = new StopWatch();
            all.start();

            MonitorGUI monText = new MonitorGUI();
            //System.out.println("DIPERF=" + worker.DIPERF);

            sw.start(); 
            monText.parseArgs(args);
            sw.stop();
            if (monText.DIPERF) System.out.println("MONITOR:parseArgs(): " + sw.getElapsedTime() + " ms");
            sw.reset();

            sw.start(); 
            if (monText.GET_WORKERS_TASKS)
            {
                monText.main_run_once(args);

            }
            else if (monText.MODE_TEXT || monText.MODE_TEXT_UI) {
                monText.main_run(args);
            } else {// if (MODE_GUI) 

                java.awt.EventQueue.invokeLater(new Runnable()
                                                {
                                                    public void run()
                                                    {
                                                        new MonitorGUI().setVisible(true);
                                                    }
                                                });
            }


            all.stop();

            if (monText.DIPERF == true) System.out.println("WORKERS:WorkTime: " + all.getElapsedTime() + " ms");
        } catch (Exception e) {
            System.out.println("WORKERS: Fatal ERROR: " + e + "... exiting");
            e.printStackTrace();
            System.exit(-1);
        }





    }

    // Variables declaration - do not modify
    private javax.swing.JTextField activeExecutors;
    private javax.swing.JTextField activeTasks;
    private javax.swing.JTextField allocatedExecutors;
    private javax.swing.JTextField bundling;
    private javax.swing.JTextField cacheHitRatio;
    private javax.swing.JTextField cacheHits;
    private javax.swing.JTextField cacheMisses;
    private javax.swing.JDesktopPane cachingPane;
    private javax.swing.JButton connectButton;
    private javax.swing.JTextField cpuUtilizationIdle;
    private javax.swing.JTextField cpuUtilizationSystem;
    private javax.swing.JTextField cpuUtilizationUser;
    private javax.swing.JTextField dataCaching;
    private javax.swing.JTextField deliverQtasks;
    private javax.swing.JTextField deliveredTP;
    private javax.swing.JTextField deliveredTasks;
    private javax.swing.JTextField dispatchTP;
    private javax.swing.JTextField drpAllocation;
    private javax.swing.JDesktopPane drpConfigPane;
    private javax.swing.JTextField drpIdle;
    private javax.swing.JTextField drpMaxResc;
    private javax.swing.JTextField drpMaxTime;
    private javax.swing.JTextField drpMinResc;
    private javax.swing.JTextField drpMinTime;
    private javax.swing.JButton exitButton;
    private javax.swing.JDesktopPane falkonConfigPane;
    private javax.swing.JTextField freeExecutors;
    private javax.swing.JDesktopPane generalPane;
    private javax.swing.JTextField heapFree;
    private javax.swing.JTextField heapMax;
    private javax.swing.JTextField heapSize;
    private javax.swing.JTextField indexSize;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel20;
    private javax.swing.JLabel jLabel21;
    private javax.swing.JLabel jLabel22;
    private javax.swing.JLabel jLabel23;
    private javax.swing.JLabel jLabel24;
    private javax.swing.JLabel jLabel25;
    private javax.swing.JLabel jLabel26;
    private javax.swing.JLabel jLabel27;
    private javax.swing.JLabel jLabel28;
    private javax.swing.JLabel jLabel29;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel30;
    private javax.swing.JLabel jLabel31;
    private javax.swing.JLabel jLabel32;
    private javax.swing.JLabel jLabel33;
    private javax.swing.JLabel jLabel34;
    private javax.swing.JLabel jLabel35;
    private javax.swing.JLabel jLabel36;
    private javax.swing.JLabel jLabel37;
    private javax.swing.JLabel jLabel38;
    private javax.swing.JLabel jLabel39;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel40;
    private javax.swing.JLabel jLabel41;
    private javax.swing.JLabel jLabel42;
    private javax.swing.JLabel jLabel43;
    private javax.swing.JLabel jLabel44;
    private javax.swing.JLabel jLabel45;
    private javax.swing.JLabel jLabel46;
    private javax.swing.JLabel jLabel47;
    private javax.swing.JLabel jLabel48;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JTextField machName;
    private javax.swing.JTextField machPort;
    private javax.swing.JTextField numQueues;
    private javax.swing.JTextField numThreads;
    private javax.swing.JTextField pendingExecutors;
    private javax.swing.JDesktopPane perfPane;
    private javax.swing.JTextField piggyBacking;
    private javax.swing.JTextField pollingInterval;
    private javax.swing.JTextField preFetching;
    private javax.swing.JTextField registeredExecutors;
    private javax.swing.JDesktopPane resourcePane;
    private javax.swing.JTextField scheduler;
    private javax.swing.JCheckBox securityCheckBox;
    private javax.swing.JTextField statusText;
    private javax.swing.JTextField submitTP;
    private javax.swing.JDesktopPane systemPane;
    private javax.swing.JDesktopPane tasksPane;
    private javax.swing.JTextField waitQlength;
    // End of variables declaration

}
